"""
Модуль heapq, кучи в Python
https://docs-python.ru/standart-library/modul-heapq-python/

Модуль heapq обеспечивает реализацию алгоритма очереди кучи, также известного как алгоритм очереди приоритетов.
Кучи - это двоичные деревья, для которых каждый родительский узел имеет значение,
меньшее или равное любому из его дочерних элементов.
В этой реализации используются массивы, для которых heap[k] <= heap[2*k+1] и heap[k] <= heap[2*k+2] для всех k,
считая элементы с нуля. Для сравнения, несуществующие элементы считаются бесконечными.
Интересным свойством кучи является то, что ее наименьшим элементом всегда является корень heap[0].

Приведенный ниже API отличается от алгоритмов кучи, описанных в учебниках в двух аспектах:

Модуль heapq использует индексацию с нуля. Это делает связь между индексом для узла и индексами для
его дочерних элементов несколько менее очевидной, но является более подходящей,
поскольку Python использует индексацию с нуля.
Метод pop() модуля heapq возвращает наименьший элемент, а не самый большой.
В учебниках он называется min heap.
Элемент max heap чаще встречается в учебниках из-за его пригодности для сортировки на месте.
Эти два аспекта позволяют просматривать кучу как обычный список Python без сюрпризов:
heap[0] - самый маленький элемент, а heap.sort() поддерживает инвариант кучи!

Чтобы создать кучу, используйте инициализацию списка [],
или можно преобразовать заполненный список в кучу с помощью функции heapq.heapify().

Функция `heappush()` модуля `heapq` добавляет значение элемента в кучу, сохраняя инвариант кучи.

Функция `heappop()` модуля `heapq` возвращает и удаляет наименьший элемент из кучи `heap`, сохраняя инвариант кучи.

Функция heappushpop() модуля heapq добавляет значение элемента item в кучу heap,
затем возвращает и удаляет самый маленький элемент из кучи heap.

Функция `heapreplace()` модуля `heapq` сначала удаляет и возвращает наименьший элемент из кучи `heap`,
а потом добавляет новый элемент `item`. Размер кучи `heap` не меняется.
Если куча пуста, поднимается исключение `IndexError`.

Функция `merge()` модуля `heapq` объединяет несколько отсортированных последовательностей `*iterables`
в один отсортированный итератор.

Функция `nlargest()` модуля `heapq` возвращает список с `n` самыми большими элементами из набора данных,
определенного с помощью итерации `iterable`.

Функция `nsmallest()` модуля `heapq` возвращает список с `n` наименьшими элементами из набора данных,
определенного с помощью итерируемой последовательности `iterable`.
"""

from heapq import *
from icecream import ic

# 01 Пирамидальная сортировка:
# Пирамидальная сортировка может быть реализована, помещая все значения в кучу, а
# затем выталкивая наименьшие значения по одному:
# Это похоже на сортировку sorted(iterable), но в отличие от встроенной функции sorted()
# эта реализация не стабильна.
def heapsort(iterable):
    h = []
    for value in iterable:
        heappush(h, value)
    return [heappop(h) for i in range(len(h))]

# 02 Назначение приоритетов задач
#  Элементы кучи могут быть кортежами.
#  Это полезно для назначений приоритетов задач вместе с основной задачей, которую нужно выполнить:

def heappush_tst():
    h = []
    heappush(h, (5, 'write code'))
    heappush(h, (7, 'release product'))
    heappush(h, (1, 'write spec'))
    heappush(h, (3, 'create tests'))
    r=heappop(h)
    return r, h
if __name__ == "__main__":
    # ic(heapsort([5,1,1,2,0,0]))
    ic(heappush_tst())
